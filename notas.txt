Receiver:
LLOPEN() -> lê a trama SET e envia o UA
LLREAD() -> lê trama I e fazer destuffing
Sender:
LLOPEN() -> envia o SET e recebe o UA
LLWRITE() -> stuffing das tramas I e enviar 

Information Frame:
F -> flag
A -> 0x03
C -> 0x00 ou 0x40 (Frame 0 ou Frame 1)
BCC1 -> A ^ C
D1 .. DN -> dados
BCC2 -> D1 ^ DN Stuffing?
F -> flag

sizeFrameMin = sizeMsg + 6
calcular BCC1 e calcular BCC2 
percorrer D1..Dn verificar D1..Dn:
					0x7E -> 0x7D 0x5E
					0X7D -> 0x7D 0x5D

Stuffing:
D1..Dn:
	0x7E -> 0x7D 0x5E
	0X7D -> 0x7D 0x5D
Falta stuffing do BCC2	

Falta acabar LLWRITE do Sender

Fazer LLClose do Sender
	Manda Disc
	espera Disc
	Manda Ua

Fazer LLClose do Receiver
	Espera Disc
	Manda Disc
	Espera Ua	

tratar de duplicates

recebe um rej temos que contar como um incremento 


State machine geral para ler interpretar tramas SET/DISC/UA/RR/REJ

Perguntar verificar receber mensagens corretas mas que nao se aplicam ao contexto 

Quando espera pelo Disc e nao recebe o que acontece?

Quando LLCLOSE da erro? timeout 

ver toda a parte da application layer

PROBLEMA A PARTIR DE CERTO TAMANHO DE PACKET A INFORMAÇÃO É ALTERADA, SE MANDAR UM PACKET COM 40 BYTES TUDO
COM 0xFF E FOR VER DO LADO DO RECEIVER A INFORMAÇÃO É ALTERADA





unsigned char* messageApp = (unsigned char*)malloc(40*sizeof(unsigned char));
    //sleep(1); 
    int sizeMessageApp = -1;
    sizeMessageApp = LLREAD(fd, messageApp);    
    
    printf("Size:%i\n",sizeMessageApp);
    for(int i = 0; i < 40; i++){
        printf("%X\n",messageApp[i]);
    }
    free(messageApp);

unsigned char Packet[40];

for(int i = 0; i < 40; i++){
Packet[i] = 0xFF;
}


